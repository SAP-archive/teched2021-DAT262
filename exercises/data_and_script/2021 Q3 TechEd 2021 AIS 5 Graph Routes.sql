/***************************************/
-- # Exercise 5 - Vessel Routes
/***************************************/

/***************************************/
-- ## Generate a Network for Path Finding

-- Let's make a network/graph on which we can calculate routes.
-- We'll take hexagon clusters as vertices and then calculate edges between.
CREATE COLUMN TABLE "AIS_DEMO"."ROUTE_NETWORK_VERTICES" (
	"ID" BIGINT PRIMARY KEY, 
	"HEXAGON" ST_GEOMETRY(32616), 
	"CENTROID" ST_GEOMETRY(32616), 
	"C" BIGINT, 
	"SHIPS" INT, 
	"SOG" DOUBLE, 
	"CARGO_FACTOR" DOUBLE DEFAULT 1.0
);

SELECT ST_CLUSTERID() AS "ID", ST_CLUSTERCELL() AS "HEXAGON", ST_CLUSTERCELL().ST_CENTROID() AS "CENTROID", 
		COUNT(*) AS C, COUNT(DISTINCT "MMSI") AS "SHIPS", AVG("SOG") AS "SOG" 
	FROM "AIS_DEMO"."AIS_2017"
	GROUP CLUSTER BY "SHAPE_32616" USING HEXAGON Y CELLS 400
	INTO "AIS_DEMO"."ROUTE_NETWORK_VERTICES" ("ID", "HEXAGON", "CENTROID", "C", "SHIPS", "SOG");

SELECT * FROM "AIS_DEMO"."ROUTE_NETWORK_VERTICES";

-- We want to find routes for cargo ships especially. So, if the cluster cell is on a frequent cargo route, we set a CARGO_FACTOR.
-- For this, we are re-using the results from the cargo ship clustering we ran in the previous exercise.
-- The higher the number of cargo ships observed in a cluster cell, the lower the cargo fact will be: 1/number of ships.
-- The "CARGO_FACTOR" will be used to calculate a least-cost path... i.e. a path that favours established cargo routes.
MERGE INTO "AIS_DEMO"."ROUTE_NETWORK_VERTICES" R
	USING (SELECT R."ID", 1/MAX(C."SHIPS") AS "CARGO_FACTOR" FROM "AIS_DEMO"."ROUTE_NETWORK_VERTICES" AS R	
		INNER JOIN "AIS_DEMO"."CLUSTER_CARGO" AS C 
		ON R."CENTROID".ST_INTERSECTS(C."SHAPE_32616") = 1
		GROUP BY R."ID") AS C
	ON R."ID" = C."ID"
	WHEN MATCHED THEN UPDATE SET R."CARGO_FACTOR" = C."CARGO_FACTOR";

SELECT MIN(CARGO_FACTOR), MAX(CARGO_FACTOR) FROM "AIS_DEMO"."ROUTE_NETWORK_VERTICES";

-- We can  construct the edges between the cluster cells. The query below identifies the neighbors of each cluster cell.
CREATE OR REPLACE VIEW "AIS_DEMO"."V_HEX_CLUSTER_NEIGHBORS" (IN i_x INT, IN i_y INT) AS 
WITH C AS (
	SELECT ELEMENT_NUMBER FROM SERIES_GENERATE_INTEGER(1, 1, :i_x+1)
	)
	SELECT * FROM (
		SELECT TWO_ROWS."SOURCE"+ALL_ROWS."OFFSET"*:i_x AS "SOURCE", TWO_ROWS."TARGET"+ALL_ROWS."OFFSET"*:i_x AS "TARGET", TWO_ROWS."NEI", TWO_ROWS."ROW_NO"+ALL_ROWS."OFFSET" AS "ROW_NO" FROM (
			SELECT "SOURCE", "TARGET", "NEI", 1 AS "ROW_NO" FROM (
				SELECT ELEMENT_NUMBER AS "SOURCE", ELEMENT_NUMBER-1 AS "TARGET", 'left' AS "NEI" FROM C WHERE ELEMENT_NUMBER > 1
				UNION
				SELECT ELEMENT_NUMBER AS "SOURCE", ELEMENT_NUMBER+1 AS "TARGET", 'right' AS "NEI" FROM C WHERE ELEMENT_NUMBER < :i_x
				UNION
				SELECT ELEMENT_NUMBER AS "SOURCE", ELEMENT_NUMBER+:i_x-1 AS "TARGET", 'left upper' AS "NEI" FROM C WHERE ELEMENT_NUMBER > 1
				UNION
				SELECT ELEMENT_NUMBER AS "SOURCE", ELEMENT_NUMBER+:i_x AS "TARGET", 'right upper' AS "NEI" FROM C
				UNION
				SELECT ELEMENT_NUMBER AS "SOURCE", ELEMENT_NUMBER-:i_x-1 AS "TARGET", 'left lower' AS "NEI" FROM C WHERE ELEMENT_NUMBER > 1
				UNION
				SELECT ELEMENT_NUMBER AS "SOURCE", ELEMENT_NUMBER-:i_x AS "TARGET", 'right lower' AS "NEI" FROM C
			) AS UNEVEN_ROW -- start with 1
			UNION
			SELECT "SOURCE", "TARGET", "NEI", 2 AS "ROW_NO" FROM (
				SELECT ELEMENT_NUMBER+:i_x AS "SOURCE", ELEMENT_NUMBER+:i_x-1 AS "TARGET", 'left' AS "NEI" FROM C WHERE ELEMENT_NUMBER > 1
				UNION
				SELECT ELEMENT_NUMBER+:i_x AS "SOURCE", ELEMENT_NUMBER+:i_x+1 AS "TARGET", 'right' AS "NEI" FROM C WHERE ELEMENT_NUMBER < :i_x
				UNION
				SELECT ELEMENT_NUMBER+:i_x AS "SOURCE", ELEMENT_NUMBER+:i_x+:i_x AS "TARGET", 'left upper' AS "NEI" FROM C
				UNION
				SELECT ELEMENT_NUMBER+:i_x AS "SOURCE", ELEMENT_NUMBER+:i_x+:i_x+1 AS "TARGET", 'right upper' AS "NEI" FROM C WHERE ELEMENT_NUMBER < :i_x
				UNION
				SELECT ELEMENT_NUMBER+:i_x AS "SOURCE", ELEMENT_NUMBER+:i_x-:i_x AS "TARGET", 'left lower' AS "NEI" FROM C
				UNION
				SELECT ELEMENT_NUMBER+:i_x AS "SOURCE", ELEMENT_NUMBER+:i_x-:i_x+1 AS "TARGET", 'right lower' AS "NEI" FROM C WHERE ELEMENT_NUMBER < :i_x
			) AS EVEN_ROW -- start with 1
		) AS TWO_ROWS
		LEFT JOIN 	
		(SELECT "GENERATED_PERIOD_START" AS "OFFSET" FROM SERIES_GENERATE_INTEGER(2, 0, :i_y+1)) AS "ALL_ROWS" ON 1=1
	)
	WHERE "TARGET" > 0 AND "TARGET" <= :i_x*:i_y AND "SOURCE" <= :i_x*:i_y
;
-- This query gives us the number of cells in X direction in our vertices/cluster table
SELECT MOD(MAX(ID), 400) FROM "AIS_DEMO"."ROUTE_NETWORK_VERTICES";

-- Create the edges table
CREATE COLUMN TABLE "AIS_DEMO"."ROUTE_NETWORK_EDGES" (
	"ID" BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
	"SOURCE" BIGINT NOT NULL,
	"TARGET" BIGINT NOT NULL,
	"LINE_32616" ST_GEOMETRY(32616),
	"LENGTH" DOUBLE,
	"AVG_C" DOUBLE,
	"AVG_SHIPS" DOUBLE,
	"AVG_SOG" DOUBLE,
	"AVG_CARGO_FACTOR" DOUBLE DEFAULT 1.0,
	"BLOCKED" BOOLEAN DEFAULT FALSE
);
-- and fill edges table
SELECT "SOURCE", "TARGET", ST_MAKELINE(C1."CENTROID", C2."CENTROID") AS "LINE_32616",
		ST_MAKELINE(C1."CENTROID", C2."CENTROID").ST_LENGTH() AS "LENGTH",
		(C1."C" + C2."C")/2 AS "AVG_C",
		(C1."SHIPS" + C2."SHIPS")/2 AS "AVG_SHIPS",
		(C1."SOG" + C2."SOG")/2 AS "AVG_SOG",
		(C1."CARGO_FACTOR" + C2."CARGO_FACTOR")/2 AS "AVG_CARGO_FACTOR"
	FROM "AIS_DEMO"."V_HEX_CLUSTER_NEIGHBORS"(400, 388) AS E -- take result from query above as size of the grid
	INNER JOIN "AIS_DEMO"."ROUTE_NETWORK_VERTICES" AS C1 ON E."SOURCE" = C1."ID"
	INNER JOIN "AIS_DEMO"."ROUTE_NETWORK_VERTICES" AS C2 ON E."TARGET" = C2."ID"
	INTO "AIS_DEMO"."ROUTE_NETWORK_EDGES"("SOURCE", "TARGET", "LINE_32616", "LENGTH", "AVG_C", "AVG_SHIPS", "AVG_SOG", "AVG_CARGO_FACTOR");
SELECT MIN("AVG_CARGO_FACTOR"),MAX("AVG_CARGO_FACTOR") FROM "AIS_DEMO"."ROUTE_NETWORK_EDGES"; 

-- Create a graph workspace
CREATE GRAPH WORKSPACE "AIS_DEMO"."ROUTE_NETWORK_GRAPH"
    EDGE TABLE "AIS_DEMO"."ROUTE_NETWORK_EDGES" SOURCE COLUMN "SOURCE" TARGET COLUMN "TARGET" KEY COLUMN "ID"
    VERTEX TABLE "AIS_DEMO"."ROUTE_NETWORK_VERTICES" KEY COLUMN "ID";

-- Shortest Path function
CREATE OR REPLACE FUNCTION "AIS_DEMO"."F_SHORTEST_PATH"(
	IN i_startVertex BIGINT, IN i_endVertex BIGINT, IN i_cargoFactorWeight DOUBLE
	)
	RETURNS TABLE ("ID" BIGINT, "VERTEX_ORDER" BIGINT)
LANGUAGE GRAPH AS
BEGIN
	GRAPH g = Graph("AIS_DEMO", "ROUTE_NETWORK_GRAPH");
	VERTEX v_start = Vertex(:g, :i_startVertex);
	VERTEX v_end = Vertex(:g, :i_endVertex);
	WeightedPath<DOUBLE> p = Shortest_Path(:g, :v_start, :v_end, (Edge e) => DOUBLE{ 
		IF (:e."BLOCKED" == FALSE) {RETURN :e."LENGTH"*(:i_cargoFactorWeight + (1.0-:i_cargoFactorWeight)*:e."AVG_CARGO_FACTOR");} 
		ELSE {END TRAVERSE;} }, 'ANY');
	RETURN SELECT :v."ID", :VERTEX_ORDER FOREACH v IN Vertices(:p) WITH ORDINALITY AS VERTEX_ORDER;
END;
SELECT * FROM "AIS_DEMO"."F_SHORTEST_PATH"(29117, 28448, 0.8) AS P LEFT JOIN "AIS_DEMO"."ROUTE_NETWORK_VERTICES" AS V ON P.ID = V.ID;



-- Wrap the function call in a view, so we can display the data in QGIS
CREATE VIEW "AIS_DEMO"."V_SHORTEST_PATH" AS (
	SELECT P."ID", P."VERTEX_ORDER", V."CENTROID"
	FROM "AIS_DEMO"."F_SHORTEST_PATH"(29117, 28448, 0.8) AS P -- chicago
	--FROM "AIS_DEMO"."F_SHORTEST_PATH"(29117, 20543, 0.8) AS P -- milwaukee 
	LEFT JOIN "AIS_DEMO"."ROUTE_NETWORK_VERTICES" AS V 
	ON P."ID" = V."ID"
);






-- Optional: persist the route (without blockage)
UPDATE "AIS_DEMO"."ROUTE_NETWORK_EDGES"	SET "BLOCKED" = FALSE;
CREATE COLUMN TABLE "AIS_DEMO"."SHORTEST_PATH_1" ( "ID" BIGINT PRIMARY KEY, "VERTEX_ORDER" BIGINT, "CENTROID" ST_GEOMETRY(32616));

SELECT P."ID", P."VERTEX_ORDER", V."CENTROID"
	FROM "AIS_DEMO"."F_SHORTEST_PATH"(29117, 28448, 0.8) AS P -- chicago
	--FROM "AIS_DEMO"."F_SHORTEST_PATH"(29117, 20543, 0.8) AS P -- milwaukee 
	LEFT JOIN "AIS_DEMO"."ROUTE_NETWORK_VERTICES" AS V 
	ON P."ID" = V."ID"
	INTO "AIS_DEMO"."SHORTEST_PATH_1";
	
-- simulate a blockage near Sturgeon Bay by setting "BLOCKED" = TRUE for all edges near this location
UPDATE "AIS_DEMO"."ROUTE_NETWORK_EDGES"
	SET "BLOCKED" = TRUE
	WHERE LINE_32616.ST_INTERSECTS(ST_GEOMFROMTEXT('POINT(-87.38079071044923 44.8311608680887)', 4326).ST_TRANSFORM(32616).ST_BUFFER(200)) = 1;
	
-- Optional: persist the alternative route 
CREATE COLUMN TABLE "AIS_DEMO"."SHORTEST_PATH_2" ( "ID" BIGINT PRIMARY KEY, "VERTEX_ORDER" BIGINT, "CENTROID" ST_GEOMETRY(32616));

SELECT P."ID", P."VERTEX_ORDER", V."CENTROID"
	FROM "AIS_DEMO"."F_SHORTEST_PATH"(29117, 28448, 0.8) AS P -- chicago
	--FROM "AIS_DEMO"."F_SHORTEST_PATH"(29117, 20543, 0.8) AS P -- 
	LEFT JOIN "AIS_DEMO"."ROUTE_NETWORK_VERTICES" AS V 
	ON P."ID" = V."ID"
	INTO "AIS_DEMO"."SHORTEST_PATH_2";



